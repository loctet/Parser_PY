Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ACCEPTEDCHAR
    ID

Grammar

Rule 0     S' -> statements
Rule 1     statements -> statement
Rule 2     statements -> statements statement
Rule 3     statement -> declaration
Rule 4     statement -> assertion
Rule 5     statement -> assignation
Rule 6     statement -> SEMICOLON statement
Rule 7     assertion -> ATOM
Rule 8     assertion -> TRUE
Rule 9     assertion -> FALSE
Rule 10    assertion -> rel_op_assertion
Rule 11    assertion -> NOT assertion
Rule 12    assertion -> and_op_assertion
Rule 13    assertion -> or_op_assertion
Rule 14    assertion -> checkin
Rule 15    assertion -> existential
Rule 16    assertion -> forall
Rule 17    assertion -> freeze
Rule 18    assertion -> LPAR assertion RPAR
Rule 19    rel_op_assertion -> expression REL_OP expression
Rule 20    and_op_assertion -> assertion AND assertion
Rule 21    or_op_assertion -> assertion OR assertion
Rule 22    expression -> fixedvalues
Rule 23    expression -> variablename
Rule 24    expression -> expression REL_OP expression
Rule 25    expression -> expression OPERATOR expression
Rule 26    expression -> PARTICIPANT DOT ATOM
Rule 27    variablename -> ATOM
Rule 28    fixedvalues -> TRUE
Rule 29    fixedvalues -> FALSE
Rule 30    fixedvalues -> INTEGER
Rule 31    fixedvalues -> STRING
Rule 32    declaration -> VTYPE ATOM
Rule 33    declaration -> VTYPE ATOM ASSIGNATION ATOM
Rule 34    declaration -> VTYPE ATOM ASSIGNATION TRUE
Rule 35    declaration -> VTYPE ATOM ASSIGNATION FALSE
Rule 36    declaration -> VTYPE ATOM ASSIGNATION INTEGER
Rule 37    declaration -> VTYPE ATOM ASSIGNATION STRING
Rule 38    declaration -> VTYPE ATOM COLON ATOM
Rule 39    assignation -> ATOM ASSIGNATION ATOM
Rule 40    assignation -> ATOM ASSIGNATION TRUE
Rule 41    assignation -> ATOM ASSIGNATION FALSE
Rule 42    assignation -> ATOM ASSIGNATION INTEGER
Rule 43    assignation -> ATOM ASSIGNATION STRING
Rule 44    checkin -> ATOM IN ATOM
Rule 45    existential -> EXISTS ATOM ATOM
Rule 46    existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR
Rule 47    forall -> FORALL ATOM ATOM
Rule 48    freeze -> FREEZE ATOM ATOM

Terminals, with rules where they appear

ACCEPTEDCHAR         : 
AND                  : 20
ASSIGNATION          : 33 34 35 36 37 39 40 41 42 43
ATOM                 : 7 26 27 32 33 33 34 35 36 37 38 38 39 39 40 41 42 43 44 44 45 45 46 46 47 47 48 48
COLON                : 38
DOT                  : 26 46
EXISTS               : 45 46
FALSE                : 9 29 35 41
FORALL               : 47
FREEZE               : 48
ID                   : 
IN                   : 44
INTEGER              : 30 36 42
LPAR                 : 18 46
NOT                  : 11
OPERATOR             : 25
OR                   : 21
PARTICIPANT          : 26
REL_OP               : 19 24
RPAR                 : 18 46
SEMICOLON            : 6
STRING               : 31 37 43
TRUE                 : 8 28 34 40
VTYPE                : 32 33 34 35 36 37 38
error                : 

Nonterminals, with rules where they appear

and_op_assertion     : 12
assertion            : 4 11 18 20 20 21 21 46
assignation          : 5
checkin              : 14
declaration          : 3
existential          : 15
expression           : 19 19 24 24 25 25
fixedvalues          : 22
forall               : 16
freeze               : 17
or_op_assertion      : 13
rel_op_assertion     : 10
statement            : 1 2 6
statements           : 2 0
variablename         : 23

Parsing method: LALR

state 0

    (0) S' -> . statements
    (1) statements -> . statement
    (2) statements -> . statements statement
    (3) statement -> . declaration
    (4) statement -> . assertion
    (5) statement -> . assignation
    (6) statement -> . SEMICOLON statement
    (32) declaration -> . VTYPE ATOM
    (33) declaration -> . VTYPE ATOM ASSIGNATION ATOM
    (34) declaration -> . VTYPE ATOM ASSIGNATION TRUE
    (35) declaration -> . VTYPE ATOM ASSIGNATION FALSE
    (36) declaration -> . VTYPE ATOM ASSIGNATION INTEGER
    (37) declaration -> . VTYPE ATOM ASSIGNATION STRING
    (38) declaration -> . VTYPE ATOM COLON ATOM
    (7) assertion -> . ATOM
    (8) assertion -> . TRUE
    (9) assertion -> . FALSE
    (10) assertion -> . rel_op_assertion
    (11) assertion -> . NOT assertion
    (12) assertion -> . and_op_assertion
    (13) assertion -> . or_op_assertion
    (14) assertion -> . checkin
    (15) assertion -> . existential
    (16) assertion -> . forall
    (17) assertion -> . freeze
    (18) assertion -> . LPAR assertion RPAR
    (39) assignation -> . ATOM ASSIGNATION ATOM
    (40) assignation -> . ATOM ASSIGNATION TRUE
    (41) assignation -> . ATOM ASSIGNATION FALSE
    (42) assignation -> . ATOM ASSIGNATION INTEGER
    (43) assignation -> . ATOM ASSIGNATION STRING
    (19) rel_op_assertion -> . expression REL_OP expression
    (20) and_op_assertion -> . assertion AND assertion
    (21) or_op_assertion -> . assertion OR assertion
    (44) checkin -> . ATOM IN ATOM
    (45) existential -> . EXISTS ATOM ATOM
    (46) existential -> . EXISTS ATOM ATOM DOT LPAR assertion RPAR
    (47) forall -> . FORALL ATOM ATOM
    (48) freeze -> . FREEZE ATOM ATOM
    (22) expression -> . fixedvalues
    (23) expression -> . variablename
    (24) expression -> . expression REL_OP expression
    (25) expression -> . expression OPERATOR expression
    (26) expression -> . PARTICIPANT DOT ATOM
    (28) fixedvalues -> . TRUE
    (29) fixedvalues -> . FALSE
    (30) fixedvalues -> . INTEGER
    (31) fixedvalues -> . STRING
    (27) variablename -> . ATOM

    SEMICOLON       shift and go to state 6
    VTYPE           shift and go to state 7
    ATOM            shift and go to state 8
    TRUE            shift and go to state 9
    FALSE           shift and go to state 10
    NOT             shift and go to state 14
    LPAR            shift and go to state 21
    EXISTS          shift and go to state 23
    FORALL          shift and go to state 24
    FREEZE          shift and go to state 25
    PARTICIPANT     shift and go to state 28
    INTEGER         shift and go to state 11
    STRING          shift and go to state 12

    statements                     shift and go to state 1
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    assertion                      shift and go to state 4
    assignation                    shift and go to state 5
    rel_op_assertion               shift and go to state 13
    and_op_assertion               shift and go to state 15
    or_op_assertion                shift and go to state 16
    checkin                        shift and go to state 17
    existential                    shift and go to state 18
    forall                         shift and go to state 19
    freeze                         shift and go to state 20
    expression                     shift and go to state 22
    fixedvalues                    shift and go to state 26
    variablename                   shift and go to state 27

state 1

    (0) S' -> statements .
    (2) statements -> statements . statement
    (3) statement -> . declaration
    (4) statement -> . assertion
    (5) statement -> . assignation
    (6) statement -> . SEMICOLON statement
    (32) declaration -> . VTYPE ATOM
    (33) declaration -> . VTYPE ATOM ASSIGNATION ATOM
    (34) declaration -> . VTYPE ATOM ASSIGNATION TRUE
    (35) declaration -> . VTYPE ATOM ASSIGNATION FALSE
    (36) declaration -> . VTYPE ATOM ASSIGNATION INTEGER
    (37) declaration -> . VTYPE ATOM ASSIGNATION STRING
    (38) declaration -> . VTYPE ATOM COLON ATOM
    (7) assertion -> . ATOM
    (8) assertion -> . TRUE
    (9) assertion -> . FALSE
    (10) assertion -> . rel_op_assertion
    (11) assertion -> . NOT assertion
    (12) assertion -> . and_op_assertion
    (13) assertion -> . or_op_assertion
    (14) assertion -> . checkin
    (15) assertion -> . existential
    (16) assertion -> . forall
    (17) assertion -> . freeze
    (18) assertion -> . LPAR assertion RPAR
    (39) assignation -> . ATOM ASSIGNATION ATOM
    (40) assignation -> . ATOM ASSIGNATION TRUE
    (41) assignation -> . ATOM ASSIGNATION FALSE
    (42) assignation -> . ATOM ASSIGNATION INTEGER
    (43) assignation -> . ATOM ASSIGNATION STRING
    (19) rel_op_assertion -> . expression REL_OP expression
    (20) and_op_assertion -> . assertion AND assertion
    (21) or_op_assertion -> . assertion OR assertion
    (44) checkin -> . ATOM IN ATOM
    (45) existential -> . EXISTS ATOM ATOM
    (46) existential -> . EXISTS ATOM ATOM DOT LPAR assertion RPAR
    (47) forall -> . FORALL ATOM ATOM
    (48) freeze -> . FREEZE ATOM ATOM
    (22) expression -> . fixedvalues
    (23) expression -> . variablename
    (24) expression -> . expression REL_OP expression
    (25) expression -> . expression OPERATOR expression
    (26) expression -> . PARTICIPANT DOT ATOM
    (28) fixedvalues -> . TRUE
    (29) fixedvalues -> . FALSE
    (30) fixedvalues -> . INTEGER
    (31) fixedvalues -> . STRING
    (27) variablename -> . ATOM

    SEMICOLON       shift and go to state 6
    VTYPE           shift and go to state 7
    ATOM            shift and go to state 8
    TRUE            shift and go to state 9
    FALSE           shift and go to state 10
    NOT             shift and go to state 14
    LPAR            shift and go to state 21
    EXISTS          shift and go to state 23
    FORALL          shift and go to state 24
    FREEZE          shift and go to state 25
    PARTICIPANT     shift and go to state 28
    INTEGER         shift and go to state 11
    STRING          shift and go to state 12

    statement                      shift and go to state 29
    declaration                    shift and go to state 3
    assertion                      shift and go to state 4
    assignation                    shift and go to state 5
    rel_op_assertion               shift and go to state 13
    and_op_assertion               shift and go to state 15
    or_op_assertion                shift and go to state 16
    checkin                        shift and go to state 17
    existential                    shift and go to state 18
    forall                         shift and go to state 19
    freeze                         shift and go to state 20
    expression                     shift and go to state 22
    fixedvalues                    shift and go to state 26
    variablename                   shift and go to state 27

state 2

    (1) statements -> statement .

    SEMICOLON       reduce using rule 1 (statements -> statement .)
    VTYPE           reduce using rule 1 (statements -> statement .)
    ATOM            reduce using rule 1 (statements -> statement .)
    TRUE            reduce using rule 1 (statements -> statement .)
    FALSE           reduce using rule 1 (statements -> statement .)
    NOT             reduce using rule 1 (statements -> statement .)
    LPAR            reduce using rule 1 (statements -> statement .)
    EXISTS          reduce using rule 1 (statements -> statement .)
    FORALL          reduce using rule 1 (statements -> statement .)
    FREEZE          reduce using rule 1 (statements -> statement .)
    PARTICIPANT     reduce using rule 1 (statements -> statement .)
    INTEGER         reduce using rule 1 (statements -> statement .)
    STRING          reduce using rule 1 (statements -> statement .)
    $end            reduce using rule 1 (statements -> statement .)


state 3

    (3) statement -> declaration .

    SEMICOLON       reduce using rule 3 (statement -> declaration .)
    VTYPE           reduce using rule 3 (statement -> declaration .)
    ATOM            reduce using rule 3 (statement -> declaration .)
    TRUE            reduce using rule 3 (statement -> declaration .)
    FALSE           reduce using rule 3 (statement -> declaration .)
    NOT             reduce using rule 3 (statement -> declaration .)
    LPAR            reduce using rule 3 (statement -> declaration .)
    EXISTS          reduce using rule 3 (statement -> declaration .)
    FORALL          reduce using rule 3 (statement -> declaration .)
    FREEZE          reduce using rule 3 (statement -> declaration .)
    PARTICIPANT     reduce using rule 3 (statement -> declaration .)
    INTEGER         reduce using rule 3 (statement -> declaration .)
    STRING          reduce using rule 3 (statement -> declaration .)
    $end            reduce using rule 3 (statement -> declaration .)


state 4

    (4) statement -> assertion .
    (20) and_op_assertion -> assertion . AND assertion
    (21) or_op_assertion -> assertion . OR assertion

    SEMICOLON       reduce using rule 4 (statement -> assertion .)
    VTYPE           reduce using rule 4 (statement -> assertion .)
    ATOM            reduce using rule 4 (statement -> assertion .)
    TRUE            reduce using rule 4 (statement -> assertion .)
    FALSE           reduce using rule 4 (statement -> assertion .)
    NOT             reduce using rule 4 (statement -> assertion .)
    LPAR            reduce using rule 4 (statement -> assertion .)
    EXISTS          reduce using rule 4 (statement -> assertion .)
    FORALL          reduce using rule 4 (statement -> assertion .)
    FREEZE          reduce using rule 4 (statement -> assertion .)
    PARTICIPANT     reduce using rule 4 (statement -> assertion .)
    INTEGER         reduce using rule 4 (statement -> assertion .)
    STRING          reduce using rule 4 (statement -> assertion .)
    $end            reduce using rule 4 (statement -> assertion .)
    AND             shift and go to state 30
    OR              shift and go to state 31


state 5

    (5) statement -> assignation .

    SEMICOLON       reduce using rule 5 (statement -> assignation .)
    VTYPE           reduce using rule 5 (statement -> assignation .)
    ATOM            reduce using rule 5 (statement -> assignation .)
    TRUE            reduce using rule 5 (statement -> assignation .)
    FALSE           reduce using rule 5 (statement -> assignation .)
    NOT             reduce using rule 5 (statement -> assignation .)
    LPAR            reduce using rule 5 (statement -> assignation .)
    EXISTS          reduce using rule 5 (statement -> assignation .)
    FORALL          reduce using rule 5 (statement -> assignation .)
    FREEZE          reduce using rule 5 (statement -> assignation .)
    PARTICIPANT     reduce using rule 5 (statement -> assignation .)
    INTEGER         reduce using rule 5 (statement -> assignation .)
    STRING          reduce using rule 5 (statement -> assignation .)
    $end            reduce using rule 5 (statement -> assignation .)


state 6

    (6) statement -> SEMICOLON . statement
    (3) statement -> . declaration
    (4) statement -> . assertion
    (5) statement -> . assignation
    (6) statement -> . SEMICOLON statement
    (32) declaration -> . VTYPE ATOM
    (33) declaration -> . VTYPE ATOM ASSIGNATION ATOM
    (34) declaration -> . VTYPE ATOM ASSIGNATION TRUE
    (35) declaration -> . VTYPE ATOM ASSIGNATION FALSE
    (36) declaration -> . VTYPE ATOM ASSIGNATION INTEGER
    (37) declaration -> . VTYPE ATOM ASSIGNATION STRING
    (38) declaration -> . VTYPE ATOM COLON ATOM
    (7) assertion -> . ATOM
    (8) assertion -> . TRUE
    (9) assertion -> . FALSE
    (10) assertion -> . rel_op_assertion
    (11) assertion -> . NOT assertion
    (12) assertion -> . and_op_assertion
    (13) assertion -> . or_op_assertion
    (14) assertion -> . checkin
    (15) assertion -> . existential
    (16) assertion -> . forall
    (17) assertion -> . freeze
    (18) assertion -> . LPAR assertion RPAR
    (39) assignation -> . ATOM ASSIGNATION ATOM
    (40) assignation -> . ATOM ASSIGNATION TRUE
    (41) assignation -> . ATOM ASSIGNATION FALSE
    (42) assignation -> . ATOM ASSIGNATION INTEGER
    (43) assignation -> . ATOM ASSIGNATION STRING
    (19) rel_op_assertion -> . expression REL_OP expression
    (20) and_op_assertion -> . assertion AND assertion
    (21) or_op_assertion -> . assertion OR assertion
    (44) checkin -> . ATOM IN ATOM
    (45) existential -> . EXISTS ATOM ATOM
    (46) existential -> . EXISTS ATOM ATOM DOT LPAR assertion RPAR
    (47) forall -> . FORALL ATOM ATOM
    (48) freeze -> . FREEZE ATOM ATOM
    (22) expression -> . fixedvalues
    (23) expression -> . variablename
    (24) expression -> . expression REL_OP expression
    (25) expression -> . expression OPERATOR expression
    (26) expression -> . PARTICIPANT DOT ATOM
    (28) fixedvalues -> . TRUE
    (29) fixedvalues -> . FALSE
    (30) fixedvalues -> . INTEGER
    (31) fixedvalues -> . STRING
    (27) variablename -> . ATOM

    SEMICOLON       shift and go to state 6
    VTYPE           shift and go to state 7
    ATOM            shift and go to state 8
    TRUE            shift and go to state 9
    FALSE           shift and go to state 10
    NOT             shift and go to state 14
    LPAR            shift and go to state 21
    EXISTS          shift and go to state 23
    FORALL          shift and go to state 24
    FREEZE          shift and go to state 25
    PARTICIPANT     shift and go to state 28
    INTEGER         shift and go to state 11
    STRING          shift and go to state 12

    statement                      shift and go to state 32
    declaration                    shift and go to state 3
    assertion                      shift and go to state 4
    assignation                    shift and go to state 5
    rel_op_assertion               shift and go to state 13
    and_op_assertion               shift and go to state 15
    or_op_assertion                shift and go to state 16
    checkin                        shift and go to state 17
    existential                    shift and go to state 18
    forall                         shift and go to state 19
    freeze                         shift and go to state 20
    expression                     shift and go to state 22
    fixedvalues                    shift and go to state 26
    variablename                   shift and go to state 27

state 7

    (32) declaration -> VTYPE . ATOM
    (33) declaration -> VTYPE . ATOM ASSIGNATION ATOM
    (34) declaration -> VTYPE . ATOM ASSIGNATION TRUE
    (35) declaration -> VTYPE . ATOM ASSIGNATION FALSE
    (36) declaration -> VTYPE . ATOM ASSIGNATION INTEGER
    (37) declaration -> VTYPE . ATOM ASSIGNATION STRING
    (38) declaration -> VTYPE . ATOM COLON ATOM

    ATOM            shift and go to state 33


state 8

    (7) assertion -> ATOM .
    (39) assignation -> ATOM . ASSIGNATION ATOM
    (40) assignation -> ATOM . ASSIGNATION TRUE
    (41) assignation -> ATOM . ASSIGNATION FALSE
    (42) assignation -> ATOM . ASSIGNATION INTEGER
    (43) assignation -> ATOM . ASSIGNATION STRING
    (44) checkin -> ATOM . IN ATOM
    (27) variablename -> ATOM .

    AND             reduce using rule 7 (assertion -> ATOM .)
    OR              reduce using rule 7 (assertion -> ATOM .)
    SEMICOLON       reduce using rule 7 (assertion -> ATOM .)
    VTYPE           reduce using rule 7 (assertion -> ATOM .)
    ATOM            reduce using rule 7 (assertion -> ATOM .)
    TRUE            reduce using rule 7 (assertion -> ATOM .)
    FALSE           reduce using rule 7 (assertion -> ATOM .)
    NOT             reduce using rule 7 (assertion -> ATOM .)
    LPAR            reduce using rule 7 (assertion -> ATOM .)
    EXISTS          reduce using rule 7 (assertion -> ATOM .)
    FORALL          reduce using rule 7 (assertion -> ATOM .)
    FREEZE          reduce using rule 7 (assertion -> ATOM .)
    PARTICIPANT     reduce using rule 7 (assertion -> ATOM .)
    INTEGER         reduce using rule 7 (assertion -> ATOM .)
    STRING          reduce using rule 7 (assertion -> ATOM .)
    $end            reduce using rule 7 (assertion -> ATOM .)
    ASSIGNATION     shift and go to state 34
    IN              shift and go to state 35
    REL_OP          reduce using rule 27 (variablename -> ATOM .)
    OPERATOR        reduce using rule 27 (variablename -> ATOM .)


state 9

    (8) assertion -> TRUE .
    (28) fixedvalues -> TRUE .

    AND             reduce using rule 8 (assertion -> TRUE .)
    OR              reduce using rule 8 (assertion -> TRUE .)
    SEMICOLON       reduce using rule 8 (assertion -> TRUE .)
    VTYPE           reduce using rule 8 (assertion -> TRUE .)
    ATOM            reduce using rule 8 (assertion -> TRUE .)
    TRUE            reduce using rule 8 (assertion -> TRUE .)
    FALSE           reduce using rule 8 (assertion -> TRUE .)
    NOT             reduce using rule 8 (assertion -> TRUE .)
    LPAR            reduce using rule 8 (assertion -> TRUE .)
    EXISTS          reduce using rule 8 (assertion -> TRUE .)
    FORALL          reduce using rule 8 (assertion -> TRUE .)
    FREEZE          reduce using rule 8 (assertion -> TRUE .)
    PARTICIPANT     reduce using rule 8 (assertion -> TRUE .)
    INTEGER         reduce using rule 8 (assertion -> TRUE .)
    STRING          reduce using rule 8 (assertion -> TRUE .)
    $end            reduce using rule 8 (assertion -> TRUE .)
    RPAR            reduce using rule 8 (assertion -> TRUE .)
    REL_OP          reduce using rule 28 (fixedvalues -> TRUE .)
    OPERATOR        reduce using rule 28 (fixedvalues -> TRUE .)


state 10

    (9) assertion -> FALSE .
    (29) fixedvalues -> FALSE .

    AND             reduce using rule 9 (assertion -> FALSE .)
    OR              reduce using rule 9 (assertion -> FALSE .)
    SEMICOLON       reduce using rule 9 (assertion -> FALSE .)
    VTYPE           reduce using rule 9 (assertion -> FALSE .)
    ATOM            reduce using rule 9 (assertion -> FALSE .)
    TRUE            reduce using rule 9 (assertion -> FALSE .)
    FALSE           reduce using rule 9 (assertion -> FALSE .)
    NOT             reduce using rule 9 (assertion -> FALSE .)
    LPAR            reduce using rule 9 (assertion -> FALSE .)
    EXISTS          reduce using rule 9 (assertion -> FALSE .)
    FORALL          reduce using rule 9 (assertion -> FALSE .)
    FREEZE          reduce using rule 9 (assertion -> FALSE .)
    PARTICIPANT     reduce using rule 9 (assertion -> FALSE .)
    INTEGER         reduce using rule 9 (assertion -> FALSE .)
    STRING          reduce using rule 9 (assertion -> FALSE .)
    $end            reduce using rule 9 (assertion -> FALSE .)
    RPAR            reduce using rule 9 (assertion -> FALSE .)
    REL_OP          reduce using rule 29 (fixedvalues -> FALSE .)
    OPERATOR        reduce using rule 29 (fixedvalues -> FALSE .)


state 11

    (30) fixedvalues -> INTEGER .

    REL_OP          reduce using rule 30 (fixedvalues -> INTEGER .)
    OPERATOR        reduce using rule 30 (fixedvalues -> INTEGER .)
    AND             reduce using rule 30 (fixedvalues -> INTEGER .)
    OR              reduce using rule 30 (fixedvalues -> INTEGER .)
    SEMICOLON       reduce using rule 30 (fixedvalues -> INTEGER .)
    VTYPE           reduce using rule 30 (fixedvalues -> INTEGER .)
    ATOM            reduce using rule 30 (fixedvalues -> INTEGER .)
    TRUE            reduce using rule 30 (fixedvalues -> INTEGER .)
    FALSE           reduce using rule 30 (fixedvalues -> INTEGER .)
    NOT             reduce using rule 30 (fixedvalues -> INTEGER .)
    LPAR            reduce using rule 30 (fixedvalues -> INTEGER .)
    EXISTS          reduce using rule 30 (fixedvalues -> INTEGER .)
    FORALL          reduce using rule 30 (fixedvalues -> INTEGER .)
    FREEZE          reduce using rule 30 (fixedvalues -> INTEGER .)
    PARTICIPANT     reduce using rule 30 (fixedvalues -> INTEGER .)
    INTEGER         reduce using rule 30 (fixedvalues -> INTEGER .)
    STRING          reduce using rule 30 (fixedvalues -> INTEGER .)
    $end            reduce using rule 30 (fixedvalues -> INTEGER .)
    RPAR            reduce using rule 30 (fixedvalues -> INTEGER .)


state 12

    (31) fixedvalues -> STRING .

    REL_OP          reduce using rule 31 (fixedvalues -> STRING .)
    OPERATOR        reduce using rule 31 (fixedvalues -> STRING .)
    AND             reduce using rule 31 (fixedvalues -> STRING .)
    OR              reduce using rule 31 (fixedvalues -> STRING .)
    SEMICOLON       reduce using rule 31 (fixedvalues -> STRING .)
    VTYPE           reduce using rule 31 (fixedvalues -> STRING .)
    ATOM            reduce using rule 31 (fixedvalues -> STRING .)
    TRUE            reduce using rule 31 (fixedvalues -> STRING .)
    FALSE           reduce using rule 31 (fixedvalues -> STRING .)
    NOT             reduce using rule 31 (fixedvalues -> STRING .)
    LPAR            reduce using rule 31 (fixedvalues -> STRING .)
    EXISTS          reduce using rule 31 (fixedvalues -> STRING .)
    FORALL          reduce using rule 31 (fixedvalues -> STRING .)
    FREEZE          reduce using rule 31 (fixedvalues -> STRING .)
    PARTICIPANT     reduce using rule 31 (fixedvalues -> STRING .)
    INTEGER         reduce using rule 31 (fixedvalues -> STRING .)
    STRING          reduce using rule 31 (fixedvalues -> STRING .)
    $end            reduce using rule 31 (fixedvalues -> STRING .)
    RPAR            reduce using rule 31 (fixedvalues -> STRING .)


state 13

    (10) assertion -> rel_op_assertion .

    AND             reduce using rule 10 (assertion -> rel_op_assertion .)
    OR              reduce using rule 10 (assertion -> rel_op_assertion .)
    SEMICOLON       reduce using rule 10 (assertion -> rel_op_assertion .)
    VTYPE           reduce using rule 10 (assertion -> rel_op_assertion .)
    ATOM            reduce using rule 10 (assertion -> rel_op_assertion .)
    TRUE            reduce using rule 10 (assertion -> rel_op_assertion .)
    FALSE           reduce using rule 10 (assertion -> rel_op_assertion .)
    NOT             reduce using rule 10 (assertion -> rel_op_assertion .)
    LPAR            reduce using rule 10 (assertion -> rel_op_assertion .)
    EXISTS          reduce using rule 10 (assertion -> rel_op_assertion .)
    FORALL          reduce using rule 10 (assertion -> rel_op_assertion .)
    FREEZE          reduce using rule 10 (assertion -> rel_op_assertion .)
    PARTICIPANT     reduce using rule 10 (assertion -> rel_op_assertion .)
    INTEGER         reduce using rule 10 (assertion -> rel_op_assertion .)
    STRING          reduce using rule 10 (assertion -> rel_op_assertion .)
    $end            reduce using rule 10 (assertion -> rel_op_assertion .)
    RPAR            reduce using rule 10 (assertion -> rel_op_assertion .)


state 14

    (11) assertion -> NOT . assertion
    (7) assertion -> . ATOM
    (8) assertion -> . TRUE
    (9) assertion -> . FALSE
    (10) assertion -> . rel_op_assertion
    (11) assertion -> . NOT assertion
    (12) assertion -> . and_op_assertion
    (13) assertion -> . or_op_assertion
    (14) assertion -> . checkin
    (15) assertion -> . existential
    (16) assertion -> . forall
    (17) assertion -> . freeze
    (18) assertion -> . LPAR assertion RPAR
    (19) rel_op_assertion -> . expression REL_OP expression
    (20) and_op_assertion -> . assertion AND assertion
    (21) or_op_assertion -> . assertion OR assertion
    (44) checkin -> . ATOM IN ATOM
    (45) existential -> . EXISTS ATOM ATOM
    (46) existential -> . EXISTS ATOM ATOM DOT LPAR assertion RPAR
    (47) forall -> . FORALL ATOM ATOM
    (48) freeze -> . FREEZE ATOM ATOM
    (22) expression -> . fixedvalues
    (23) expression -> . variablename
    (24) expression -> . expression REL_OP expression
    (25) expression -> . expression OPERATOR expression
    (26) expression -> . PARTICIPANT DOT ATOM
    (28) fixedvalues -> . TRUE
    (29) fixedvalues -> . FALSE
    (30) fixedvalues -> . INTEGER
    (31) fixedvalues -> . STRING
    (27) variablename -> . ATOM

    ATOM            shift and go to state 37
    TRUE            shift and go to state 9
    FALSE           shift and go to state 10
    NOT             shift and go to state 14
    LPAR            shift and go to state 21
    EXISTS          shift and go to state 23
    FORALL          shift and go to state 24
    FREEZE          shift and go to state 25
    PARTICIPANT     shift and go to state 28
    INTEGER         shift and go to state 11
    STRING          shift and go to state 12

    assertion                      shift and go to state 36
    rel_op_assertion               shift and go to state 13
    and_op_assertion               shift and go to state 15
    or_op_assertion                shift and go to state 16
    checkin                        shift and go to state 17
    existential                    shift and go to state 18
    forall                         shift and go to state 19
    freeze                         shift and go to state 20
    expression                     shift and go to state 22
    fixedvalues                    shift and go to state 26
    variablename                   shift and go to state 27

state 15

    (12) assertion -> and_op_assertion .

    AND             reduce using rule 12 (assertion -> and_op_assertion .)
    OR              reduce using rule 12 (assertion -> and_op_assertion .)
    SEMICOLON       reduce using rule 12 (assertion -> and_op_assertion .)
    VTYPE           reduce using rule 12 (assertion -> and_op_assertion .)
    ATOM            reduce using rule 12 (assertion -> and_op_assertion .)
    TRUE            reduce using rule 12 (assertion -> and_op_assertion .)
    FALSE           reduce using rule 12 (assertion -> and_op_assertion .)
    NOT             reduce using rule 12 (assertion -> and_op_assertion .)
    LPAR            reduce using rule 12 (assertion -> and_op_assertion .)
    EXISTS          reduce using rule 12 (assertion -> and_op_assertion .)
    FORALL          reduce using rule 12 (assertion -> and_op_assertion .)
    FREEZE          reduce using rule 12 (assertion -> and_op_assertion .)
    PARTICIPANT     reduce using rule 12 (assertion -> and_op_assertion .)
    INTEGER         reduce using rule 12 (assertion -> and_op_assertion .)
    STRING          reduce using rule 12 (assertion -> and_op_assertion .)
    $end            reduce using rule 12 (assertion -> and_op_assertion .)
    RPAR            reduce using rule 12 (assertion -> and_op_assertion .)


state 16

    (13) assertion -> or_op_assertion .

    AND             reduce using rule 13 (assertion -> or_op_assertion .)
    OR              reduce using rule 13 (assertion -> or_op_assertion .)
    SEMICOLON       reduce using rule 13 (assertion -> or_op_assertion .)
    VTYPE           reduce using rule 13 (assertion -> or_op_assertion .)
    ATOM            reduce using rule 13 (assertion -> or_op_assertion .)
    TRUE            reduce using rule 13 (assertion -> or_op_assertion .)
    FALSE           reduce using rule 13 (assertion -> or_op_assertion .)
    NOT             reduce using rule 13 (assertion -> or_op_assertion .)
    LPAR            reduce using rule 13 (assertion -> or_op_assertion .)
    EXISTS          reduce using rule 13 (assertion -> or_op_assertion .)
    FORALL          reduce using rule 13 (assertion -> or_op_assertion .)
    FREEZE          reduce using rule 13 (assertion -> or_op_assertion .)
    PARTICIPANT     reduce using rule 13 (assertion -> or_op_assertion .)
    INTEGER         reduce using rule 13 (assertion -> or_op_assertion .)
    STRING          reduce using rule 13 (assertion -> or_op_assertion .)
    $end            reduce using rule 13 (assertion -> or_op_assertion .)
    RPAR            reduce using rule 13 (assertion -> or_op_assertion .)


state 17

    (14) assertion -> checkin .

    AND             reduce using rule 14 (assertion -> checkin .)
    OR              reduce using rule 14 (assertion -> checkin .)
    SEMICOLON       reduce using rule 14 (assertion -> checkin .)
    VTYPE           reduce using rule 14 (assertion -> checkin .)
    ATOM            reduce using rule 14 (assertion -> checkin .)
    TRUE            reduce using rule 14 (assertion -> checkin .)
    FALSE           reduce using rule 14 (assertion -> checkin .)
    NOT             reduce using rule 14 (assertion -> checkin .)
    LPAR            reduce using rule 14 (assertion -> checkin .)
    EXISTS          reduce using rule 14 (assertion -> checkin .)
    FORALL          reduce using rule 14 (assertion -> checkin .)
    FREEZE          reduce using rule 14 (assertion -> checkin .)
    PARTICIPANT     reduce using rule 14 (assertion -> checkin .)
    INTEGER         reduce using rule 14 (assertion -> checkin .)
    STRING          reduce using rule 14 (assertion -> checkin .)
    $end            reduce using rule 14 (assertion -> checkin .)
    RPAR            reduce using rule 14 (assertion -> checkin .)


state 18

    (15) assertion -> existential .

    AND             reduce using rule 15 (assertion -> existential .)
    OR              reduce using rule 15 (assertion -> existential .)
    SEMICOLON       reduce using rule 15 (assertion -> existential .)
    VTYPE           reduce using rule 15 (assertion -> existential .)
    ATOM            reduce using rule 15 (assertion -> existential .)
    TRUE            reduce using rule 15 (assertion -> existential .)
    FALSE           reduce using rule 15 (assertion -> existential .)
    NOT             reduce using rule 15 (assertion -> existential .)
    LPAR            reduce using rule 15 (assertion -> existential .)
    EXISTS          reduce using rule 15 (assertion -> existential .)
    FORALL          reduce using rule 15 (assertion -> existential .)
    FREEZE          reduce using rule 15 (assertion -> existential .)
    PARTICIPANT     reduce using rule 15 (assertion -> existential .)
    INTEGER         reduce using rule 15 (assertion -> existential .)
    STRING          reduce using rule 15 (assertion -> existential .)
    $end            reduce using rule 15 (assertion -> existential .)
    RPAR            reduce using rule 15 (assertion -> existential .)


state 19

    (16) assertion -> forall .

    AND             reduce using rule 16 (assertion -> forall .)
    OR              reduce using rule 16 (assertion -> forall .)
    SEMICOLON       reduce using rule 16 (assertion -> forall .)
    VTYPE           reduce using rule 16 (assertion -> forall .)
    ATOM            reduce using rule 16 (assertion -> forall .)
    TRUE            reduce using rule 16 (assertion -> forall .)
    FALSE           reduce using rule 16 (assertion -> forall .)
    NOT             reduce using rule 16 (assertion -> forall .)
    LPAR            reduce using rule 16 (assertion -> forall .)
    EXISTS          reduce using rule 16 (assertion -> forall .)
    FORALL          reduce using rule 16 (assertion -> forall .)
    FREEZE          reduce using rule 16 (assertion -> forall .)
    PARTICIPANT     reduce using rule 16 (assertion -> forall .)
    INTEGER         reduce using rule 16 (assertion -> forall .)
    STRING          reduce using rule 16 (assertion -> forall .)
    $end            reduce using rule 16 (assertion -> forall .)
    RPAR            reduce using rule 16 (assertion -> forall .)


state 20

    (17) assertion -> freeze .

    AND             reduce using rule 17 (assertion -> freeze .)
    OR              reduce using rule 17 (assertion -> freeze .)
    SEMICOLON       reduce using rule 17 (assertion -> freeze .)
    VTYPE           reduce using rule 17 (assertion -> freeze .)
    ATOM            reduce using rule 17 (assertion -> freeze .)
    TRUE            reduce using rule 17 (assertion -> freeze .)
    FALSE           reduce using rule 17 (assertion -> freeze .)
    NOT             reduce using rule 17 (assertion -> freeze .)
    LPAR            reduce using rule 17 (assertion -> freeze .)
    EXISTS          reduce using rule 17 (assertion -> freeze .)
    FORALL          reduce using rule 17 (assertion -> freeze .)
    FREEZE          reduce using rule 17 (assertion -> freeze .)
    PARTICIPANT     reduce using rule 17 (assertion -> freeze .)
    INTEGER         reduce using rule 17 (assertion -> freeze .)
    STRING          reduce using rule 17 (assertion -> freeze .)
    $end            reduce using rule 17 (assertion -> freeze .)
    RPAR            reduce using rule 17 (assertion -> freeze .)


state 21

    (18) assertion -> LPAR . assertion RPAR
    (7) assertion -> . ATOM
    (8) assertion -> . TRUE
    (9) assertion -> . FALSE
    (10) assertion -> . rel_op_assertion
    (11) assertion -> . NOT assertion
    (12) assertion -> . and_op_assertion
    (13) assertion -> . or_op_assertion
    (14) assertion -> . checkin
    (15) assertion -> . existential
    (16) assertion -> . forall
    (17) assertion -> . freeze
    (18) assertion -> . LPAR assertion RPAR
    (19) rel_op_assertion -> . expression REL_OP expression
    (20) and_op_assertion -> . assertion AND assertion
    (21) or_op_assertion -> . assertion OR assertion
    (44) checkin -> . ATOM IN ATOM
    (45) existential -> . EXISTS ATOM ATOM
    (46) existential -> . EXISTS ATOM ATOM DOT LPAR assertion RPAR
    (47) forall -> . FORALL ATOM ATOM
    (48) freeze -> . FREEZE ATOM ATOM
    (22) expression -> . fixedvalues
    (23) expression -> . variablename
    (24) expression -> . expression REL_OP expression
    (25) expression -> . expression OPERATOR expression
    (26) expression -> . PARTICIPANT DOT ATOM
    (28) fixedvalues -> . TRUE
    (29) fixedvalues -> . FALSE
    (30) fixedvalues -> . INTEGER
    (31) fixedvalues -> . STRING
    (27) variablename -> . ATOM

    ATOM            shift and go to state 37
    TRUE            shift and go to state 9
    FALSE           shift and go to state 10
    NOT             shift and go to state 14
    LPAR            shift and go to state 21
    EXISTS          shift and go to state 23
    FORALL          shift and go to state 24
    FREEZE          shift and go to state 25
    PARTICIPANT     shift and go to state 28
    INTEGER         shift and go to state 11
    STRING          shift and go to state 12

    assertion                      shift and go to state 38
    rel_op_assertion               shift and go to state 13
    and_op_assertion               shift and go to state 15
    or_op_assertion                shift and go to state 16
    checkin                        shift and go to state 17
    existential                    shift and go to state 18
    forall                         shift and go to state 19
    freeze                         shift and go to state 20
    expression                     shift and go to state 22
    fixedvalues                    shift and go to state 26
    variablename                   shift and go to state 27

state 22

    (19) rel_op_assertion -> expression . REL_OP expression
    (24) expression -> expression . REL_OP expression
    (25) expression -> expression . OPERATOR expression

    REL_OP          shift and go to state 39
    OPERATOR        shift and go to state 40


state 23

    (45) existential -> EXISTS . ATOM ATOM
    (46) existential -> EXISTS . ATOM ATOM DOT LPAR assertion RPAR

    ATOM            shift and go to state 41


state 24

    (47) forall -> FORALL . ATOM ATOM

    ATOM            shift and go to state 42


state 25

    (48) freeze -> FREEZE . ATOM ATOM

    ATOM            shift and go to state 43


state 26

    (22) expression -> fixedvalues .

    REL_OP          reduce using rule 22 (expression -> fixedvalues .)
    OPERATOR        reduce using rule 22 (expression -> fixedvalues .)
    AND             reduce using rule 22 (expression -> fixedvalues .)
    OR              reduce using rule 22 (expression -> fixedvalues .)
    SEMICOLON       reduce using rule 22 (expression -> fixedvalues .)
    VTYPE           reduce using rule 22 (expression -> fixedvalues .)
    ATOM            reduce using rule 22 (expression -> fixedvalues .)
    TRUE            reduce using rule 22 (expression -> fixedvalues .)
    FALSE           reduce using rule 22 (expression -> fixedvalues .)
    NOT             reduce using rule 22 (expression -> fixedvalues .)
    LPAR            reduce using rule 22 (expression -> fixedvalues .)
    EXISTS          reduce using rule 22 (expression -> fixedvalues .)
    FORALL          reduce using rule 22 (expression -> fixedvalues .)
    FREEZE          reduce using rule 22 (expression -> fixedvalues .)
    PARTICIPANT     reduce using rule 22 (expression -> fixedvalues .)
    INTEGER         reduce using rule 22 (expression -> fixedvalues .)
    STRING          reduce using rule 22 (expression -> fixedvalues .)
    $end            reduce using rule 22 (expression -> fixedvalues .)
    RPAR            reduce using rule 22 (expression -> fixedvalues .)


state 27

    (23) expression -> variablename .

    REL_OP          reduce using rule 23 (expression -> variablename .)
    OPERATOR        reduce using rule 23 (expression -> variablename .)
    AND             reduce using rule 23 (expression -> variablename .)
    OR              reduce using rule 23 (expression -> variablename .)
    SEMICOLON       reduce using rule 23 (expression -> variablename .)
    VTYPE           reduce using rule 23 (expression -> variablename .)
    ATOM            reduce using rule 23 (expression -> variablename .)
    TRUE            reduce using rule 23 (expression -> variablename .)
    FALSE           reduce using rule 23 (expression -> variablename .)
    NOT             reduce using rule 23 (expression -> variablename .)
    LPAR            reduce using rule 23 (expression -> variablename .)
    EXISTS          reduce using rule 23 (expression -> variablename .)
    FORALL          reduce using rule 23 (expression -> variablename .)
    FREEZE          reduce using rule 23 (expression -> variablename .)
    PARTICIPANT     reduce using rule 23 (expression -> variablename .)
    INTEGER         reduce using rule 23 (expression -> variablename .)
    STRING          reduce using rule 23 (expression -> variablename .)
    $end            reduce using rule 23 (expression -> variablename .)
    RPAR            reduce using rule 23 (expression -> variablename .)


state 28

    (26) expression -> PARTICIPANT . DOT ATOM

    DOT             shift and go to state 44


state 29

    (2) statements -> statements statement .

    SEMICOLON       reduce using rule 2 (statements -> statements statement .)
    VTYPE           reduce using rule 2 (statements -> statements statement .)
    ATOM            reduce using rule 2 (statements -> statements statement .)
    TRUE            reduce using rule 2 (statements -> statements statement .)
    FALSE           reduce using rule 2 (statements -> statements statement .)
    NOT             reduce using rule 2 (statements -> statements statement .)
    LPAR            reduce using rule 2 (statements -> statements statement .)
    EXISTS          reduce using rule 2 (statements -> statements statement .)
    FORALL          reduce using rule 2 (statements -> statements statement .)
    FREEZE          reduce using rule 2 (statements -> statements statement .)
    PARTICIPANT     reduce using rule 2 (statements -> statements statement .)
    INTEGER         reduce using rule 2 (statements -> statements statement .)
    STRING          reduce using rule 2 (statements -> statements statement .)
    $end            reduce using rule 2 (statements -> statements statement .)


state 30

    (20) and_op_assertion -> assertion AND . assertion
    (7) assertion -> . ATOM
    (8) assertion -> . TRUE
    (9) assertion -> . FALSE
    (10) assertion -> . rel_op_assertion
    (11) assertion -> . NOT assertion
    (12) assertion -> . and_op_assertion
    (13) assertion -> . or_op_assertion
    (14) assertion -> . checkin
    (15) assertion -> . existential
    (16) assertion -> . forall
    (17) assertion -> . freeze
    (18) assertion -> . LPAR assertion RPAR
    (19) rel_op_assertion -> . expression REL_OP expression
    (20) and_op_assertion -> . assertion AND assertion
    (21) or_op_assertion -> . assertion OR assertion
    (44) checkin -> . ATOM IN ATOM
    (45) existential -> . EXISTS ATOM ATOM
    (46) existential -> . EXISTS ATOM ATOM DOT LPAR assertion RPAR
    (47) forall -> . FORALL ATOM ATOM
    (48) freeze -> . FREEZE ATOM ATOM
    (22) expression -> . fixedvalues
    (23) expression -> . variablename
    (24) expression -> . expression REL_OP expression
    (25) expression -> . expression OPERATOR expression
    (26) expression -> . PARTICIPANT DOT ATOM
    (28) fixedvalues -> . TRUE
    (29) fixedvalues -> . FALSE
    (30) fixedvalues -> . INTEGER
    (31) fixedvalues -> . STRING
    (27) variablename -> . ATOM

    ATOM            shift and go to state 37
    TRUE            shift and go to state 9
    FALSE           shift and go to state 10
    NOT             shift and go to state 14
    LPAR            shift and go to state 21
    EXISTS          shift and go to state 23
    FORALL          shift and go to state 24
    FREEZE          shift and go to state 25
    PARTICIPANT     shift and go to state 28
    INTEGER         shift and go to state 11
    STRING          shift and go to state 12

    assertion                      shift and go to state 45
    rel_op_assertion               shift and go to state 13
    and_op_assertion               shift and go to state 15
    or_op_assertion                shift and go to state 16
    checkin                        shift and go to state 17
    existential                    shift and go to state 18
    forall                         shift and go to state 19
    freeze                         shift and go to state 20
    expression                     shift and go to state 22
    fixedvalues                    shift and go to state 26
    variablename                   shift and go to state 27

state 31

    (21) or_op_assertion -> assertion OR . assertion
    (7) assertion -> . ATOM
    (8) assertion -> . TRUE
    (9) assertion -> . FALSE
    (10) assertion -> . rel_op_assertion
    (11) assertion -> . NOT assertion
    (12) assertion -> . and_op_assertion
    (13) assertion -> . or_op_assertion
    (14) assertion -> . checkin
    (15) assertion -> . existential
    (16) assertion -> . forall
    (17) assertion -> . freeze
    (18) assertion -> . LPAR assertion RPAR
    (19) rel_op_assertion -> . expression REL_OP expression
    (20) and_op_assertion -> . assertion AND assertion
    (21) or_op_assertion -> . assertion OR assertion
    (44) checkin -> . ATOM IN ATOM
    (45) existential -> . EXISTS ATOM ATOM
    (46) existential -> . EXISTS ATOM ATOM DOT LPAR assertion RPAR
    (47) forall -> . FORALL ATOM ATOM
    (48) freeze -> . FREEZE ATOM ATOM
    (22) expression -> . fixedvalues
    (23) expression -> . variablename
    (24) expression -> . expression REL_OP expression
    (25) expression -> . expression OPERATOR expression
    (26) expression -> . PARTICIPANT DOT ATOM
    (28) fixedvalues -> . TRUE
    (29) fixedvalues -> . FALSE
    (30) fixedvalues -> . INTEGER
    (31) fixedvalues -> . STRING
    (27) variablename -> . ATOM

    ATOM            shift and go to state 37
    TRUE            shift and go to state 9
    FALSE           shift and go to state 10
    NOT             shift and go to state 14
    LPAR            shift and go to state 21
    EXISTS          shift and go to state 23
    FORALL          shift and go to state 24
    FREEZE          shift and go to state 25
    PARTICIPANT     shift and go to state 28
    INTEGER         shift and go to state 11
    STRING          shift and go to state 12

    assertion                      shift and go to state 46
    rel_op_assertion               shift and go to state 13
    and_op_assertion               shift and go to state 15
    or_op_assertion                shift and go to state 16
    checkin                        shift and go to state 17
    existential                    shift and go to state 18
    forall                         shift and go to state 19
    freeze                         shift and go to state 20
    expression                     shift and go to state 22
    fixedvalues                    shift and go to state 26
    variablename                   shift and go to state 27

state 32

    (6) statement -> SEMICOLON statement .

    SEMICOLON       reduce using rule 6 (statement -> SEMICOLON statement .)
    VTYPE           reduce using rule 6 (statement -> SEMICOLON statement .)
    ATOM            reduce using rule 6 (statement -> SEMICOLON statement .)
    TRUE            reduce using rule 6 (statement -> SEMICOLON statement .)
    FALSE           reduce using rule 6 (statement -> SEMICOLON statement .)
    NOT             reduce using rule 6 (statement -> SEMICOLON statement .)
    LPAR            reduce using rule 6 (statement -> SEMICOLON statement .)
    EXISTS          reduce using rule 6 (statement -> SEMICOLON statement .)
    FORALL          reduce using rule 6 (statement -> SEMICOLON statement .)
    FREEZE          reduce using rule 6 (statement -> SEMICOLON statement .)
    PARTICIPANT     reduce using rule 6 (statement -> SEMICOLON statement .)
    INTEGER         reduce using rule 6 (statement -> SEMICOLON statement .)
    STRING          reduce using rule 6 (statement -> SEMICOLON statement .)
    $end            reduce using rule 6 (statement -> SEMICOLON statement .)


state 33

    (32) declaration -> VTYPE ATOM .
    (33) declaration -> VTYPE ATOM . ASSIGNATION ATOM
    (34) declaration -> VTYPE ATOM . ASSIGNATION TRUE
    (35) declaration -> VTYPE ATOM . ASSIGNATION FALSE
    (36) declaration -> VTYPE ATOM . ASSIGNATION INTEGER
    (37) declaration -> VTYPE ATOM . ASSIGNATION STRING
    (38) declaration -> VTYPE ATOM . COLON ATOM

    SEMICOLON       reduce using rule 32 (declaration -> VTYPE ATOM .)
    VTYPE           reduce using rule 32 (declaration -> VTYPE ATOM .)
    ATOM            reduce using rule 32 (declaration -> VTYPE ATOM .)
    TRUE            reduce using rule 32 (declaration -> VTYPE ATOM .)
    FALSE           reduce using rule 32 (declaration -> VTYPE ATOM .)
    NOT             reduce using rule 32 (declaration -> VTYPE ATOM .)
    LPAR            reduce using rule 32 (declaration -> VTYPE ATOM .)
    EXISTS          reduce using rule 32 (declaration -> VTYPE ATOM .)
    FORALL          reduce using rule 32 (declaration -> VTYPE ATOM .)
    FREEZE          reduce using rule 32 (declaration -> VTYPE ATOM .)
    PARTICIPANT     reduce using rule 32 (declaration -> VTYPE ATOM .)
    INTEGER         reduce using rule 32 (declaration -> VTYPE ATOM .)
    STRING          reduce using rule 32 (declaration -> VTYPE ATOM .)
    $end            reduce using rule 32 (declaration -> VTYPE ATOM .)
    ASSIGNATION     shift and go to state 47
    COLON           shift and go to state 48


state 34

    (39) assignation -> ATOM ASSIGNATION . ATOM
    (40) assignation -> ATOM ASSIGNATION . TRUE
    (41) assignation -> ATOM ASSIGNATION . FALSE
    (42) assignation -> ATOM ASSIGNATION . INTEGER
    (43) assignation -> ATOM ASSIGNATION . STRING

    ATOM            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    INTEGER         shift and go to state 52
    STRING          shift and go to state 53


state 35

    (44) checkin -> ATOM IN . ATOM

    ATOM            shift and go to state 54


state 36

    (11) assertion -> NOT assertion .
    (20) and_op_assertion -> assertion . AND assertion
    (21) or_op_assertion -> assertion . OR assertion

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 11 (assertion -> NOT assertion .)
    VTYPE           reduce using rule 11 (assertion -> NOT assertion .)
    ATOM            reduce using rule 11 (assertion -> NOT assertion .)
    TRUE            reduce using rule 11 (assertion -> NOT assertion .)
    FALSE           reduce using rule 11 (assertion -> NOT assertion .)
    NOT             reduce using rule 11 (assertion -> NOT assertion .)
    LPAR            reduce using rule 11 (assertion -> NOT assertion .)
    EXISTS          reduce using rule 11 (assertion -> NOT assertion .)
    FORALL          reduce using rule 11 (assertion -> NOT assertion .)
    FREEZE          reduce using rule 11 (assertion -> NOT assertion .)
    PARTICIPANT     reduce using rule 11 (assertion -> NOT assertion .)
    INTEGER         reduce using rule 11 (assertion -> NOT assertion .)
    STRING          reduce using rule 11 (assertion -> NOT assertion .)
    $end            reduce using rule 11 (assertion -> NOT assertion .)
    RPAR            reduce using rule 11 (assertion -> NOT assertion .)
    AND             shift and go to state 30
    OR              shift and go to state 31

  ! AND             [ reduce using rule 11 (assertion -> NOT assertion .) ]
  ! OR              [ reduce using rule 11 (assertion -> NOT assertion .) ]


state 37

    (7) assertion -> ATOM .
    (44) checkin -> ATOM . IN ATOM
    (27) variablename -> ATOM .

    AND             reduce using rule 7 (assertion -> ATOM .)
    OR              reduce using rule 7 (assertion -> ATOM .)
    SEMICOLON       reduce using rule 7 (assertion -> ATOM .)
    VTYPE           reduce using rule 7 (assertion -> ATOM .)
    ATOM            reduce using rule 7 (assertion -> ATOM .)
    TRUE            reduce using rule 7 (assertion -> ATOM .)
    FALSE           reduce using rule 7 (assertion -> ATOM .)
    NOT             reduce using rule 7 (assertion -> ATOM .)
    LPAR            reduce using rule 7 (assertion -> ATOM .)
    EXISTS          reduce using rule 7 (assertion -> ATOM .)
    FORALL          reduce using rule 7 (assertion -> ATOM .)
    FREEZE          reduce using rule 7 (assertion -> ATOM .)
    PARTICIPANT     reduce using rule 7 (assertion -> ATOM .)
    INTEGER         reduce using rule 7 (assertion -> ATOM .)
    STRING          reduce using rule 7 (assertion -> ATOM .)
    $end            reduce using rule 7 (assertion -> ATOM .)
    RPAR            reduce using rule 7 (assertion -> ATOM .)
    IN              shift and go to state 35
    REL_OP          reduce using rule 27 (variablename -> ATOM .)
    OPERATOR        reduce using rule 27 (variablename -> ATOM .)


state 38

    (18) assertion -> LPAR assertion . RPAR
    (20) and_op_assertion -> assertion . AND assertion
    (21) or_op_assertion -> assertion . OR assertion

    RPAR            shift and go to state 55
    AND             shift and go to state 30
    OR              shift and go to state 31


state 39

    (19) rel_op_assertion -> expression REL_OP . expression
    (24) expression -> expression REL_OP . expression
    (22) expression -> . fixedvalues
    (23) expression -> . variablename
    (24) expression -> . expression REL_OP expression
    (25) expression -> . expression OPERATOR expression
    (26) expression -> . PARTICIPANT DOT ATOM
    (28) fixedvalues -> . TRUE
    (29) fixedvalues -> . FALSE
    (30) fixedvalues -> . INTEGER
    (31) fixedvalues -> . STRING
    (27) variablename -> . ATOM

    PARTICIPANT     shift and go to state 28
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    INTEGER         shift and go to state 11
    STRING          shift and go to state 12
    ATOM            shift and go to state 57

    expression                     shift and go to state 56
    fixedvalues                    shift and go to state 26
    variablename                   shift and go to state 27

state 40

    (25) expression -> expression OPERATOR . expression
    (22) expression -> . fixedvalues
    (23) expression -> . variablename
    (24) expression -> . expression REL_OP expression
    (25) expression -> . expression OPERATOR expression
    (26) expression -> . PARTICIPANT DOT ATOM
    (28) fixedvalues -> . TRUE
    (29) fixedvalues -> . FALSE
    (30) fixedvalues -> . INTEGER
    (31) fixedvalues -> . STRING
    (27) variablename -> . ATOM

    PARTICIPANT     shift and go to state 28
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    INTEGER         shift and go to state 11
    STRING          shift and go to state 12
    ATOM            shift and go to state 57

    expression                     shift and go to state 60
    fixedvalues                    shift and go to state 26
    variablename                   shift and go to state 27

state 41

    (45) existential -> EXISTS ATOM . ATOM
    (46) existential -> EXISTS ATOM . ATOM DOT LPAR assertion RPAR

    ATOM            shift and go to state 61


state 42

    (47) forall -> FORALL ATOM . ATOM

    ATOM            shift and go to state 62


state 43

    (48) freeze -> FREEZE ATOM . ATOM

    ATOM            shift and go to state 63


state 44

    (26) expression -> PARTICIPANT DOT . ATOM

    ATOM            shift and go to state 64


state 45

    (20) and_op_assertion -> assertion AND assertion .
    (20) and_op_assertion -> assertion . AND assertion
    (21) or_op_assertion -> assertion . OR assertion

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    VTYPE           reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    ATOM            reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    TRUE            reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    FALSE           reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    NOT             reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    LPAR            reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    EXISTS          reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    FORALL          reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    FREEZE          reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    PARTICIPANT     reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    INTEGER         reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    STRING          reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    $end            reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    RPAR            reduce using rule 20 (and_op_assertion -> assertion AND assertion .)
    AND             shift and go to state 30
    OR              shift and go to state 31

  ! AND             [ reduce using rule 20 (and_op_assertion -> assertion AND assertion .) ]
  ! OR              [ reduce using rule 20 (and_op_assertion -> assertion AND assertion .) ]


state 46

    (21) or_op_assertion -> assertion OR assertion .
    (20) and_op_assertion -> assertion . AND assertion
    (21) or_op_assertion -> assertion . OR assertion

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    VTYPE           reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    ATOM            reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    TRUE            reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    FALSE           reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    NOT             reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    LPAR            reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    EXISTS          reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    FORALL          reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    FREEZE          reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    PARTICIPANT     reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    INTEGER         reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    STRING          reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    $end            reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    RPAR            reduce using rule 21 (or_op_assertion -> assertion OR assertion .)
    AND             shift and go to state 30
    OR              shift and go to state 31

  ! AND             [ reduce using rule 21 (or_op_assertion -> assertion OR assertion .) ]
  ! OR              [ reduce using rule 21 (or_op_assertion -> assertion OR assertion .) ]


state 47

    (33) declaration -> VTYPE ATOM ASSIGNATION . ATOM
    (34) declaration -> VTYPE ATOM ASSIGNATION . TRUE
    (35) declaration -> VTYPE ATOM ASSIGNATION . FALSE
    (36) declaration -> VTYPE ATOM ASSIGNATION . INTEGER
    (37) declaration -> VTYPE ATOM ASSIGNATION . STRING

    ATOM            shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    INTEGER         shift and go to state 68
    STRING          shift and go to state 69


state 48

    (38) declaration -> VTYPE ATOM COLON . ATOM

    ATOM            shift and go to state 70


state 49

    (39) assignation -> ATOM ASSIGNATION ATOM .

    SEMICOLON       reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    VTYPE           reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    ATOM            reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    TRUE            reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    FALSE           reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    NOT             reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    LPAR            reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    EXISTS          reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    FORALL          reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    FREEZE          reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    PARTICIPANT     reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    INTEGER         reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    STRING          reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)
    $end            reduce using rule 39 (assignation -> ATOM ASSIGNATION ATOM .)


state 50

    (40) assignation -> ATOM ASSIGNATION TRUE .

    SEMICOLON       reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    VTYPE           reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    ATOM            reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    TRUE            reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    FALSE           reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    NOT             reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    LPAR            reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    EXISTS          reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    FORALL          reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    FREEZE          reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    PARTICIPANT     reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    INTEGER         reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    STRING          reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)
    $end            reduce using rule 40 (assignation -> ATOM ASSIGNATION TRUE .)


state 51

    (41) assignation -> ATOM ASSIGNATION FALSE .

    SEMICOLON       reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    VTYPE           reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    ATOM            reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    TRUE            reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    FALSE           reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    NOT             reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    LPAR            reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    EXISTS          reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    FORALL          reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    FREEZE          reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    PARTICIPANT     reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    INTEGER         reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    STRING          reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)
    $end            reduce using rule 41 (assignation -> ATOM ASSIGNATION FALSE .)


state 52

    (42) assignation -> ATOM ASSIGNATION INTEGER .

    SEMICOLON       reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    VTYPE           reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    ATOM            reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    TRUE            reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    FALSE           reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    NOT             reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    LPAR            reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    EXISTS          reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    FORALL          reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    FREEZE          reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    PARTICIPANT     reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    INTEGER         reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    STRING          reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)
    $end            reduce using rule 42 (assignation -> ATOM ASSIGNATION INTEGER .)


state 53

    (43) assignation -> ATOM ASSIGNATION STRING .

    SEMICOLON       reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    VTYPE           reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    ATOM            reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    TRUE            reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    FALSE           reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    NOT             reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    LPAR            reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    EXISTS          reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    FORALL          reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    FREEZE          reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    PARTICIPANT     reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    INTEGER         reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    STRING          reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)
    $end            reduce using rule 43 (assignation -> ATOM ASSIGNATION STRING .)


state 54

    (44) checkin -> ATOM IN ATOM .

    AND             reduce using rule 44 (checkin -> ATOM IN ATOM .)
    OR              reduce using rule 44 (checkin -> ATOM IN ATOM .)
    SEMICOLON       reduce using rule 44 (checkin -> ATOM IN ATOM .)
    VTYPE           reduce using rule 44 (checkin -> ATOM IN ATOM .)
    ATOM            reduce using rule 44 (checkin -> ATOM IN ATOM .)
    TRUE            reduce using rule 44 (checkin -> ATOM IN ATOM .)
    FALSE           reduce using rule 44 (checkin -> ATOM IN ATOM .)
    NOT             reduce using rule 44 (checkin -> ATOM IN ATOM .)
    LPAR            reduce using rule 44 (checkin -> ATOM IN ATOM .)
    EXISTS          reduce using rule 44 (checkin -> ATOM IN ATOM .)
    FORALL          reduce using rule 44 (checkin -> ATOM IN ATOM .)
    FREEZE          reduce using rule 44 (checkin -> ATOM IN ATOM .)
    PARTICIPANT     reduce using rule 44 (checkin -> ATOM IN ATOM .)
    INTEGER         reduce using rule 44 (checkin -> ATOM IN ATOM .)
    STRING          reduce using rule 44 (checkin -> ATOM IN ATOM .)
    $end            reduce using rule 44 (checkin -> ATOM IN ATOM .)
    RPAR            reduce using rule 44 (checkin -> ATOM IN ATOM .)


state 55

    (18) assertion -> LPAR assertion RPAR .

    AND             reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    OR              reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    SEMICOLON       reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    VTYPE           reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    ATOM            reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    TRUE            reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    FALSE           reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    NOT             reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    LPAR            reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    EXISTS          reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    FORALL          reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    FREEZE          reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    PARTICIPANT     reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    INTEGER         reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    STRING          reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    $end            reduce using rule 18 (assertion -> LPAR assertion RPAR .)
    RPAR            reduce using rule 18 (assertion -> LPAR assertion RPAR .)


state 56

    (19) rel_op_assertion -> expression REL_OP expression .
    (24) expression -> expression REL_OP expression .
    (24) expression -> expression . REL_OP expression
    (25) expression -> expression . OPERATOR expression

  ! shift/reduce conflict for REL_OP resolved as shift
  ! shift/reduce conflict for OPERATOR resolved as shift
    AND             reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    OR              reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    SEMICOLON       reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    VTYPE           reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    ATOM            reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    TRUE            reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    FALSE           reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    NOT             reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    LPAR            reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    EXISTS          reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    FORALL          reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    FREEZE          reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    PARTICIPANT     reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    INTEGER         reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    STRING          reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    $end            reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    RPAR            reduce using rule 19 (rel_op_assertion -> expression REL_OP expression .)
    REL_OP          shift and go to state 71
    OPERATOR        shift and go to state 40

  ! REL_OP          [ reduce using rule 24 (expression -> expression REL_OP expression .) ]
  ! OPERATOR        [ reduce using rule 24 (expression -> expression REL_OP expression .) ]


state 57

    (27) variablename -> ATOM .

    REL_OP          reduce using rule 27 (variablename -> ATOM .)
    OPERATOR        reduce using rule 27 (variablename -> ATOM .)
    AND             reduce using rule 27 (variablename -> ATOM .)
    OR              reduce using rule 27 (variablename -> ATOM .)
    SEMICOLON       reduce using rule 27 (variablename -> ATOM .)
    VTYPE           reduce using rule 27 (variablename -> ATOM .)
    ATOM            reduce using rule 27 (variablename -> ATOM .)
    TRUE            reduce using rule 27 (variablename -> ATOM .)
    FALSE           reduce using rule 27 (variablename -> ATOM .)
    NOT             reduce using rule 27 (variablename -> ATOM .)
    LPAR            reduce using rule 27 (variablename -> ATOM .)
    EXISTS          reduce using rule 27 (variablename -> ATOM .)
    FORALL          reduce using rule 27 (variablename -> ATOM .)
    FREEZE          reduce using rule 27 (variablename -> ATOM .)
    PARTICIPANT     reduce using rule 27 (variablename -> ATOM .)
    INTEGER         reduce using rule 27 (variablename -> ATOM .)
    STRING          reduce using rule 27 (variablename -> ATOM .)
    $end            reduce using rule 27 (variablename -> ATOM .)
    RPAR            reduce using rule 27 (variablename -> ATOM .)


state 58

    (28) fixedvalues -> TRUE .

    REL_OP          reduce using rule 28 (fixedvalues -> TRUE .)
    OPERATOR        reduce using rule 28 (fixedvalues -> TRUE .)
    AND             reduce using rule 28 (fixedvalues -> TRUE .)
    OR              reduce using rule 28 (fixedvalues -> TRUE .)
    SEMICOLON       reduce using rule 28 (fixedvalues -> TRUE .)
    VTYPE           reduce using rule 28 (fixedvalues -> TRUE .)
    ATOM            reduce using rule 28 (fixedvalues -> TRUE .)
    TRUE            reduce using rule 28 (fixedvalues -> TRUE .)
    FALSE           reduce using rule 28 (fixedvalues -> TRUE .)
    NOT             reduce using rule 28 (fixedvalues -> TRUE .)
    LPAR            reduce using rule 28 (fixedvalues -> TRUE .)
    EXISTS          reduce using rule 28 (fixedvalues -> TRUE .)
    FORALL          reduce using rule 28 (fixedvalues -> TRUE .)
    FREEZE          reduce using rule 28 (fixedvalues -> TRUE .)
    PARTICIPANT     reduce using rule 28 (fixedvalues -> TRUE .)
    INTEGER         reduce using rule 28 (fixedvalues -> TRUE .)
    STRING          reduce using rule 28 (fixedvalues -> TRUE .)
    $end            reduce using rule 28 (fixedvalues -> TRUE .)
    RPAR            reduce using rule 28 (fixedvalues -> TRUE .)


state 59

    (29) fixedvalues -> FALSE .

    REL_OP          reduce using rule 29 (fixedvalues -> FALSE .)
    OPERATOR        reduce using rule 29 (fixedvalues -> FALSE .)
    AND             reduce using rule 29 (fixedvalues -> FALSE .)
    OR              reduce using rule 29 (fixedvalues -> FALSE .)
    SEMICOLON       reduce using rule 29 (fixedvalues -> FALSE .)
    VTYPE           reduce using rule 29 (fixedvalues -> FALSE .)
    ATOM            reduce using rule 29 (fixedvalues -> FALSE .)
    TRUE            reduce using rule 29 (fixedvalues -> FALSE .)
    FALSE           reduce using rule 29 (fixedvalues -> FALSE .)
    NOT             reduce using rule 29 (fixedvalues -> FALSE .)
    LPAR            reduce using rule 29 (fixedvalues -> FALSE .)
    EXISTS          reduce using rule 29 (fixedvalues -> FALSE .)
    FORALL          reduce using rule 29 (fixedvalues -> FALSE .)
    FREEZE          reduce using rule 29 (fixedvalues -> FALSE .)
    PARTICIPANT     reduce using rule 29 (fixedvalues -> FALSE .)
    INTEGER         reduce using rule 29 (fixedvalues -> FALSE .)
    STRING          reduce using rule 29 (fixedvalues -> FALSE .)
    $end            reduce using rule 29 (fixedvalues -> FALSE .)
    RPAR            reduce using rule 29 (fixedvalues -> FALSE .)


state 60

    (25) expression -> expression OPERATOR expression .
    (24) expression -> expression . REL_OP expression
    (25) expression -> expression . OPERATOR expression

  ! shift/reduce conflict for REL_OP resolved as shift
  ! shift/reduce conflict for OPERATOR resolved as shift
    AND             reduce using rule 25 (expression -> expression OPERATOR expression .)
    OR              reduce using rule 25 (expression -> expression OPERATOR expression .)
    SEMICOLON       reduce using rule 25 (expression -> expression OPERATOR expression .)
    VTYPE           reduce using rule 25 (expression -> expression OPERATOR expression .)
    ATOM            reduce using rule 25 (expression -> expression OPERATOR expression .)
    TRUE            reduce using rule 25 (expression -> expression OPERATOR expression .)
    FALSE           reduce using rule 25 (expression -> expression OPERATOR expression .)
    NOT             reduce using rule 25 (expression -> expression OPERATOR expression .)
    LPAR            reduce using rule 25 (expression -> expression OPERATOR expression .)
    EXISTS          reduce using rule 25 (expression -> expression OPERATOR expression .)
    FORALL          reduce using rule 25 (expression -> expression OPERATOR expression .)
    FREEZE          reduce using rule 25 (expression -> expression OPERATOR expression .)
    PARTICIPANT     reduce using rule 25 (expression -> expression OPERATOR expression .)
    INTEGER         reduce using rule 25 (expression -> expression OPERATOR expression .)
    STRING          reduce using rule 25 (expression -> expression OPERATOR expression .)
    $end            reduce using rule 25 (expression -> expression OPERATOR expression .)
    RPAR            reduce using rule 25 (expression -> expression OPERATOR expression .)
    REL_OP          shift and go to state 71
    OPERATOR        shift and go to state 40

  ! REL_OP          [ reduce using rule 25 (expression -> expression OPERATOR expression .) ]
  ! OPERATOR        [ reduce using rule 25 (expression -> expression OPERATOR expression .) ]


state 61

    (45) existential -> EXISTS ATOM ATOM .
    (46) existential -> EXISTS ATOM ATOM . DOT LPAR assertion RPAR

    AND             reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    OR              reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    SEMICOLON       reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    VTYPE           reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    ATOM            reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    TRUE            reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    FALSE           reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    NOT             reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    LPAR            reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    EXISTS          reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    FORALL          reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    FREEZE          reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    PARTICIPANT     reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    INTEGER         reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    STRING          reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    $end            reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    RPAR            reduce using rule 45 (existential -> EXISTS ATOM ATOM .)
    DOT             shift and go to state 72


state 62

    (47) forall -> FORALL ATOM ATOM .

    AND             reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    OR              reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    SEMICOLON       reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    VTYPE           reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    ATOM            reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    TRUE            reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    FALSE           reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    NOT             reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    LPAR            reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    EXISTS          reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    FORALL          reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    FREEZE          reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    PARTICIPANT     reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    INTEGER         reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    STRING          reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    $end            reduce using rule 47 (forall -> FORALL ATOM ATOM .)
    RPAR            reduce using rule 47 (forall -> FORALL ATOM ATOM .)


state 63

    (48) freeze -> FREEZE ATOM ATOM .

    AND             reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    OR              reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    SEMICOLON       reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    VTYPE           reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    ATOM            reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    TRUE            reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    FALSE           reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    NOT             reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    LPAR            reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    EXISTS          reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    FORALL          reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    FREEZE          reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    PARTICIPANT     reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    INTEGER         reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    STRING          reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    $end            reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)
    RPAR            reduce using rule 48 (freeze -> FREEZE ATOM ATOM .)


state 64

    (26) expression -> PARTICIPANT DOT ATOM .

    REL_OP          reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    OPERATOR        reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    AND             reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    OR              reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    SEMICOLON       reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    VTYPE           reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    ATOM            reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    TRUE            reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    FALSE           reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    NOT             reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    LPAR            reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    EXISTS          reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    FORALL          reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    FREEZE          reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    PARTICIPANT     reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    INTEGER         reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    STRING          reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    $end            reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)
    RPAR            reduce using rule 26 (expression -> PARTICIPANT DOT ATOM .)


state 65

    (33) declaration -> VTYPE ATOM ASSIGNATION ATOM .

    SEMICOLON       reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    VTYPE           reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    ATOM            reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    TRUE            reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    FALSE           reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    NOT             reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    LPAR            reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    EXISTS          reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    FORALL          reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    FREEZE          reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    PARTICIPANT     reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    INTEGER         reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    STRING          reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)
    $end            reduce using rule 33 (declaration -> VTYPE ATOM ASSIGNATION ATOM .)


state 66

    (34) declaration -> VTYPE ATOM ASSIGNATION TRUE .

    SEMICOLON       reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    VTYPE           reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    ATOM            reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    TRUE            reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    FALSE           reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    NOT             reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    LPAR            reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    EXISTS          reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    FORALL          reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    FREEZE          reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    PARTICIPANT     reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    INTEGER         reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    STRING          reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)
    $end            reduce using rule 34 (declaration -> VTYPE ATOM ASSIGNATION TRUE .)


state 67

    (35) declaration -> VTYPE ATOM ASSIGNATION FALSE .

    SEMICOLON       reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    VTYPE           reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    ATOM            reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    TRUE            reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    FALSE           reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    NOT             reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    LPAR            reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    EXISTS          reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    FORALL          reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    FREEZE          reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    PARTICIPANT     reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    INTEGER         reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    STRING          reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)
    $end            reduce using rule 35 (declaration -> VTYPE ATOM ASSIGNATION FALSE .)


state 68

    (36) declaration -> VTYPE ATOM ASSIGNATION INTEGER .

    SEMICOLON       reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    VTYPE           reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    ATOM            reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    TRUE            reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    FALSE           reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    NOT             reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    LPAR            reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    EXISTS          reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    FORALL          reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    FREEZE          reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    PARTICIPANT     reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    INTEGER         reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    STRING          reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)
    $end            reduce using rule 36 (declaration -> VTYPE ATOM ASSIGNATION INTEGER .)


state 69

    (37) declaration -> VTYPE ATOM ASSIGNATION STRING .

    SEMICOLON       reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    VTYPE           reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    ATOM            reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    TRUE            reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    FALSE           reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    NOT             reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    LPAR            reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    EXISTS          reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    FORALL          reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    FREEZE          reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    PARTICIPANT     reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    INTEGER         reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    STRING          reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)
    $end            reduce using rule 37 (declaration -> VTYPE ATOM ASSIGNATION STRING .)


state 70

    (38) declaration -> VTYPE ATOM COLON ATOM .

    SEMICOLON       reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    VTYPE           reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    ATOM            reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    TRUE            reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    FALSE           reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    NOT             reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    LPAR            reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    EXISTS          reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    FORALL          reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    FREEZE          reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    PARTICIPANT     reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    INTEGER         reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    STRING          reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)
    $end            reduce using rule 38 (declaration -> VTYPE ATOM COLON ATOM .)


state 71

    (24) expression -> expression REL_OP . expression
    (22) expression -> . fixedvalues
    (23) expression -> . variablename
    (24) expression -> . expression REL_OP expression
    (25) expression -> . expression OPERATOR expression
    (26) expression -> . PARTICIPANT DOT ATOM
    (28) fixedvalues -> . TRUE
    (29) fixedvalues -> . FALSE
    (30) fixedvalues -> . INTEGER
    (31) fixedvalues -> . STRING
    (27) variablename -> . ATOM

    PARTICIPANT     shift and go to state 28
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    INTEGER         shift and go to state 11
    STRING          shift and go to state 12
    ATOM            shift and go to state 57

    expression                     shift and go to state 73
    fixedvalues                    shift and go to state 26
    variablename                   shift and go to state 27

state 72

    (46) existential -> EXISTS ATOM ATOM DOT . LPAR assertion RPAR

    LPAR            shift and go to state 74


state 73

    (24) expression -> expression REL_OP expression .
    (24) expression -> expression . REL_OP expression
    (25) expression -> expression . OPERATOR expression

  ! shift/reduce conflict for REL_OP resolved as shift
  ! shift/reduce conflict for OPERATOR resolved as shift
    AND             reduce using rule 24 (expression -> expression REL_OP expression .)
    OR              reduce using rule 24 (expression -> expression REL_OP expression .)
    SEMICOLON       reduce using rule 24 (expression -> expression REL_OP expression .)
    VTYPE           reduce using rule 24 (expression -> expression REL_OP expression .)
    ATOM            reduce using rule 24 (expression -> expression REL_OP expression .)
    TRUE            reduce using rule 24 (expression -> expression REL_OP expression .)
    FALSE           reduce using rule 24 (expression -> expression REL_OP expression .)
    NOT             reduce using rule 24 (expression -> expression REL_OP expression .)
    LPAR            reduce using rule 24 (expression -> expression REL_OP expression .)
    EXISTS          reduce using rule 24 (expression -> expression REL_OP expression .)
    FORALL          reduce using rule 24 (expression -> expression REL_OP expression .)
    FREEZE          reduce using rule 24 (expression -> expression REL_OP expression .)
    PARTICIPANT     reduce using rule 24 (expression -> expression REL_OP expression .)
    INTEGER         reduce using rule 24 (expression -> expression REL_OP expression .)
    STRING          reduce using rule 24 (expression -> expression REL_OP expression .)
    $end            reduce using rule 24 (expression -> expression REL_OP expression .)
    RPAR            reduce using rule 24 (expression -> expression REL_OP expression .)
    REL_OP          shift and go to state 71
    OPERATOR        shift and go to state 40

  ! REL_OP          [ reduce using rule 24 (expression -> expression REL_OP expression .) ]
  ! OPERATOR        [ reduce using rule 24 (expression -> expression REL_OP expression .) ]


state 74

    (46) existential -> EXISTS ATOM ATOM DOT LPAR . assertion RPAR
    (7) assertion -> . ATOM
    (8) assertion -> . TRUE
    (9) assertion -> . FALSE
    (10) assertion -> . rel_op_assertion
    (11) assertion -> . NOT assertion
    (12) assertion -> . and_op_assertion
    (13) assertion -> . or_op_assertion
    (14) assertion -> . checkin
    (15) assertion -> . existential
    (16) assertion -> . forall
    (17) assertion -> . freeze
    (18) assertion -> . LPAR assertion RPAR
    (19) rel_op_assertion -> . expression REL_OP expression
    (20) and_op_assertion -> . assertion AND assertion
    (21) or_op_assertion -> . assertion OR assertion
    (44) checkin -> . ATOM IN ATOM
    (45) existential -> . EXISTS ATOM ATOM
    (46) existential -> . EXISTS ATOM ATOM DOT LPAR assertion RPAR
    (47) forall -> . FORALL ATOM ATOM
    (48) freeze -> . FREEZE ATOM ATOM
    (22) expression -> . fixedvalues
    (23) expression -> . variablename
    (24) expression -> . expression REL_OP expression
    (25) expression -> . expression OPERATOR expression
    (26) expression -> . PARTICIPANT DOT ATOM
    (28) fixedvalues -> . TRUE
    (29) fixedvalues -> . FALSE
    (30) fixedvalues -> . INTEGER
    (31) fixedvalues -> . STRING
    (27) variablename -> . ATOM

    ATOM            shift and go to state 37
    TRUE            shift and go to state 9
    FALSE           shift and go to state 10
    NOT             shift and go to state 14
    LPAR            shift and go to state 21
    EXISTS          shift and go to state 23
    FORALL          shift and go to state 24
    FREEZE          shift and go to state 25
    PARTICIPANT     shift and go to state 28
    INTEGER         shift and go to state 11
    STRING          shift and go to state 12

    assertion                      shift and go to state 75
    rel_op_assertion               shift and go to state 13
    and_op_assertion               shift and go to state 15
    or_op_assertion                shift and go to state 16
    checkin                        shift and go to state 17
    existential                    shift and go to state 18
    forall                         shift and go to state 19
    freeze                         shift and go to state 20
    expression                     shift and go to state 22
    fixedvalues                    shift and go to state 26
    variablename                   shift and go to state 27

state 75

    (46) existential -> EXISTS ATOM ATOM DOT LPAR assertion . RPAR
    (20) and_op_assertion -> assertion . AND assertion
    (21) or_op_assertion -> assertion . OR assertion

    RPAR            shift and go to state 76
    AND             shift and go to state 30
    OR              shift and go to state 31


state 76

    (46) existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .

    AND             reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    OR              reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    SEMICOLON       reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    VTYPE           reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    ATOM            reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    TRUE            reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    FALSE           reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    NOT             reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    LPAR            reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    EXISTS          reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    FORALL          reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    FREEZE          reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    PARTICIPANT     reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    INTEGER         reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    STRING          reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    $end            reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)
    RPAR            reduce using rule 46 (existential -> EXISTS ATOM ATOM DOT LPAR assertion RPAR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 36 resolved as shift
WARNING: shift/reduce conflict for OR in state 36 resolved as shift
WARNING: shift/reduce conflict for AND in state 45 resolved as shift
WARNING: shift/reduce conflict for OR in state 45 resolved as shift
WARNING: shift/reduce conflict for AND in state 46 resolved as shift
WARNING: shift/reduce conflict for OR in state 46 resolved as shift
WARNING: shift/reduce conflict for REL_OP in state 56 resolved as shift
WARNING: shift/reduce conflict for OPERATOR in state 56 resolved as shift
WARNING: shift/reduce conflict for REL_OP in state 60 resolved as shift
WARNING: shift/reduce conflict for OPERATOR in state 60 resolved as shift
WARNING: shift/reduce conflict for REL_OP in state 73 resolved as shift
WARNING: shift/reduce conflict for OPERATOR in state 73 resolved as shift
